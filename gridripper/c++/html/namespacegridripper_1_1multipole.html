<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GridRipper: gridripper::multipole Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacegridripper.html">gridripper</a>::<a class="el" href="namespacegridripper_1_1multipole.html">multipole</a>
  </div>
</div>
<div class="contents">
<h1>gridripper::multipole Namespace Reference</h1>Multipole expansion classes and methods.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for spherical harmonic functions.  <a href="classgridripper_1_1multipole_1_1Y.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridripper_1_1multipole_1_1Yre.html">Yre</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for real spherical harmonic functions.  <a href="classgridripper_1_1multipole_1_1Yre.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridripper_1_1multipole_1_1Coeff_3_01GReal__t_01_4.html">Coeff&lt; GReal_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for real spherical harmonic (<a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a>) expansion coefficients.  <a href="classgridripper_1_1multipole_1_1Coeff_3_01GReal__t_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridripper_1_1multipole_1_1Coeff_3_01GComplex__t_01_4.html">Coeff&lt; GComplex_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for complex spherical harmonic (<a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a>) expansion coefficients.  <a href="classgridripper_1_1multipole_1_1Coeff_3_01GComplex__t_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GReal__t_01_4.html">ScalarFieldMP&lt; GReal_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for real scalar fields on sphere.  <a href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GReal__t_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GComplex__t_01_4.html">ScalarFieldMP&lt; GComplex_t &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for complex scalar fields on sphere.  <a href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GComplex__t_01_4.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#f12d46f0a50e3f65b5f7fcfa4b55da02">operator*</a> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>, const <a class="el" href="classgridripper_1_1multipole_1_1Yre.html">Yre</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tensor product of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a>.  <a href="#f12d46f0a50e3f65b5f7fcfa4b55da02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="734614babe475081a0d0232d927070eb"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="734614babe475081a0d0232d927070eb" args="(const Yre &amp;, const GReal_t)" -->
Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgridripper_1_1multipole_1_1Yre.html">Yre</a> &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#b24502a97a729ab064db028f94ad90d2">operator/</a> (const <a class="el" href="classgridripper_1_1multipole_1_1Yre.html">Yre</a> &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tensor quotient of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a>.  <a href="#b24502a97a729ab064db028f94ad90d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#2e16ce21df912ed1b9a964121bd12cc3">operator*</a> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>, const Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a coefficient by a number.  <a href="#2e16ce21df912ed1b9a964121bd12cc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="615515ecc02f1f0cf1bd35e320a29f95"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="615515ecc02f1f0cf1bd35e320a29f95" args="(const Coeff&lt; GReal_t &gt; &amp;, const GReal_t)" -->
Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#1646ea6267e2dc583778d380da0455e0">operator/</a> (const Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide a coefficient by a number.  <a href="#1646ea6267e2dc583778d380da0455e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#b96dfe1a6cd2d3a68675c67869571604">operator-</a> (const <a class="el" href="classgridripper_1_1multipole_1_1Yre.html">Yre</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negative of a coefficient.  <a href="#b96dfe1a6cd2d3a68675c67869571604"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="03a58ebc969db0600edbd4e4e8203198"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="03a58ebc969db0600edbd4e4e8203198" args="(const Coeff&lt; GReal_t &gt; &amp;)" -->
Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const Coeff&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#7a6c723945acb12cf72b377a85387571">operator*</a> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>, const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tensor product of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a>.  <a href="#7a6c723945acb12cf72b377a85387571"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="64da63be0f099014809ee348b75d71bd"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="64da63be0f099014809ee348b75d71bd" args="(const Y &amp;, const GReal_t)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="85a1b46e1de9393d85b78c98e81ab47c"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="85a1b46e1de9393d85b78c98e81ab47c" args="(const GComplex_t &amp;, const Y &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const GComplex_t &amp;, const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e5f375d833d9ca2f2c37661207fe11b3"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="e5f375d833d9ca2f2c37661207fe11b3" args="(const Y &amp;, const GComplex_t &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#7937b30ef8c8948a79875c7f7d6c8c48">operator/</a> (const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tensor quotient of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a>.  <a href="#7937b30ef8c8948a79875c7f7d6c8c48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9fd94e980a8e6bff7910eafa52fcc6e"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="b9fd94e980a8e6bff7910eafa52fcc6e" args="(const Y &amp;, const GComplex_t &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#93b2dbce3fff7b5f6fef3838f6f6eb17">operator*</a> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>, const Coeff&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a coefficient by a number.  <a href="#93b2dbce3fff7b5f6fef3838f6f6eb17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8adfc7e2781ceb1217250c7bd2b28aaa"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="8adfc7e2781ceb1217250c7bd2b28aaa" args="(const Coeff&lt; GComplex_t &gt; &amp;, const GReal_t)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const Coeff&lt; GComplex_t &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="802c600c13616456395d07a9dba384eb"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="802c600c13616456395d07a9dba384eb" args="(const GComplex_t &amp;, const Coeff&lt; GComplex_t &gt; &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const GComplex_t &amp;, const Coeff&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c47f9fb74333460ebdba468045dad72"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="3c47f9fb74333460ebdba468045dad72" args="(const Coeff&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const Coeff&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#232340cab0325ce3b17e92c3bbcbee79">operator/</a> (const Coeff&lt; GComplex_t &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide a coefficient by a number.  <a href="#232340cab0325ce3b17e92c3bbcbee79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16dcd0fbb9541fca917528b06dacb21"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="a16dcd0fbb9541fca917528b06dacb21" args="(const Coeff&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const Coeff&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#748b9a50c76550f6c74d8b1203d4ae81">operator-</a> (const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negative of a coefficient.  <a href="#748b9a50c76550f6c74d8b1203d4ae81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a217900150d55c09266dc75e44dc9dca"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="a217900150d55c09266dc75e44dc9dca" args="(const Coeff&lt; GComplex_t &gt; &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const Coeff&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#69a213fe40035e4c164b09f60acadbcd">conj</a> (const <a class="el" href="classgridripper_1_1multipole_1_1Y.html">Y</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complex conjugate a coefficient.  <a href="#69a213fe40035e4c164b09f60acadbcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="792e97170f16a5f57e75232e4d573313"></a><!-- doxytag: member="gridripper::multipole::conj" ref="792e97170f16a5f57e75232e4d573313" args="(const Coeff&lt; GComplex_t &gt; &amp;)" -->
Coeff&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>conj</b> (const Coeff&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#9ad30d051132bf73154603e04085e96f">YYY_coupling</a> (const int l1, const int l2, const int l3, const int m1, const int m2, const int m3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <img class="formulaInl" alt="$ \int_{0}^{\pi}\int_{0}^{2\pi} Y_{l_1}^{m_1}(\vartheta, \varphi) Y_{l_2}^{m_2}(\vartheta, \varphi) Y_{l_3}^{m_3}(\vartheta, \varphi) \;\sin(\vartheta)\mathrm{d}\vartheta\,\mathrm{d}\varphi $" src="form_17.png"> spherical harmonic function Gaunt coefficient calculator routine.  <a href="#9ad30d051132bf73154603e04085e96f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#0261db9ddc27a4efc117b490be2df9a3">YYY_coupling_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show table size currently used in YYY_coupling.  <a href="#0261db9ddc27a4efc117b490be2df9a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#4efb9210174e454646c6ce517d769cae">YreYreYre_coupling</a> (const int l1, const int l2, const int l3, const int m1, const int m2, const int m3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The same coupling for <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a> basis.  <a href="#4efb9210174e454646c6ce517d769cae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#ffa1b1c56cd150f3257677b858f7ac7f">YYreY_coupling</a> (const int l1, const int l2, const int l3, const int m1, const int m2, const int m3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar coupling for <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a> and <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a> basis.  <a href="#ffa1b1c56cd150f3257677b858f7ac7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#c7dd8c132463b0ee92c42dee0141de79">intYl1ExpMIPhi</a> (const int l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculation of <img class="formulaInl" alt="$\int_{0}^{2\pi}\int_{0}^{\pi} Y_{l}^{1}(\vartheta, \varphi) \exp(-\mathrm{i}\varphi) \sin(\vartheta)\;\mathrm{d}\vartheta\,\mathrm{d}\varphi$" src="form_31.png">.  <a href="#c7dd8c132463b0ee92c42dee0141de79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#e876b678b59e8d1a161641a2c2d40072">ExpPmIPhiYY_coupling</a> (const int l1, const int m1, const int l2, const int sign)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The overlap integrals <img class="formulaInl" alt="$\int_{0}^{\pi}\int_{0}^{2\pi} \mathrm{e}^{\pm\mathrm{i}\varphi} Y_{l_1}^{m_1}(\vartheta, \varphi) Y_{l_2}^{-(m_1\pm1)}(\vartheta, \varphi) \;\sin(\vartheta)\mathrm{d}\vartheta\,\mathrm{d}\varphi$" src="form_35.png">.  <a href="#e876b678b59e8d1a161641a2c2d40072"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#b75f0e976ae2d1526f2ba013e828c02f">ExpPmIPhiYY_coupling_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show table size currently used in ExpPmIPhiYY_coupling.  <a href="#b75f0e976ae2d1526f2ba013e828c02f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#5bed2f2660f11bb006c18fd66217a79d">intYl0</a> (const int l, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> theta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculation of <img class="formulaInl" alt="$\int_{[0,\theta]\times[0,2\pi]} Y_{l}^{0} \;\mathrm{d}\lambda_{S^2}$" src="form_43.png">.  <a href="#5bed2f2660f11bb006c18fd66217a79d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#9024b80824536167ace62ed4574ad0ec">intBarYl1mYl2m</a> (const int l1, const int l2, const int m, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> theta, <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &gt; &gt; *coeffstorage)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculation of <img class="formulaInl" alt="$\int_{[0,\theta]\times[0,2\pi]} \bar{Y}_{l_1}^{m} Y_{l_2}^{m} \;\mathrm{d}\lambda_{S^2}$" src="form_46.png">.  <a href="#9024b80824536167ace62ed4574ad0ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#aa406903fe05c91acc2e9893dc53ee54">SobolevConstantS2</a> (const int m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The minimal Sobolev constant in the inequality over the sphere: <img class="formulaInl" alt="$\Vert\cdot\Vert_{C^{0}} \leq C \Vert\cdot\Vert_{H^{2}_{\mu}}$" src="form_50.png">.  <a href="#aa406903fe05c91acc2e9893dc53ee54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d292a8c954ef14aab655b3312c6d5956"></a><!-- doxytag: member="gridripper::multipole::tailSumS2" ref="d292a8c954ef14aab655b3312c6d5956" args="(const int mup, const int mu, const int L)" -->
<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#d292a8c954ef14aab655b3312c6d5956">tailSumS2</a> (const int mup, const int mu, const int L)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The sum <img class="formulaInl" alt="$\sum_{l=L}^{\infty} \sum_{m=-l}^{l} \frac{(l(l+1))^{\mu+1}-1}{(l(l+1))^{\mu^{'}+1}-1} \frac{1}{(2l+1)^{2}}$" src="form_52.png">. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#67683cdbcc011c89273e6cd16dcb09f5">operator+</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GReal__t_01_4.html" title="Class for real scalar fields on sphere.">ScalarFieldMP&lt;GReal_t&gt;</a> algebraic operators.  <a href="#67683cdbcc011c89273e6cd16dcb09f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a6bc0e2961d309ce94aca77eb425c7c"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="3a6bc0e2961d309ce94aca77eb425c7c" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f551b89b54e608f87cedbefeec9ffcfd"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="f551b89b54e608f87cedbefeec9ffcfd" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff0e12f7b2f76262020f45168c1b9550"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="ff0e12f7b2f76262020f45168c1b9550" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const GReal_t)" -->
ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1699c6472354c51b76e576c10de9400d"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="1699c6472354c51b76e576c10de9400d" args="(const GReal_t, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32615ee225003fa65e05576a6c02982a"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="32615ee225003fa65e05576a6c02982a" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f0b6abbe42491aeafe8680b258143c9"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="1f0b6abbe42491aeafe8680b258143c9" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const GReal_t)" -->
ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#cfbe86f5ff178b8fde432b8f22df0e4d">L2S2</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">L^2 scalarproduct of two fields on sphere.  <a href="#cfbe86f5ff178b8fde432b8f22df0e4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2e49ec76411e4dc53376bb2bfbf1979"></a><!-- doxytag: member="gridripper::multipole::H2S2" ref="f2e49ec76411e4dc53376bb2bfbf1979" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;, const int mu)" -->
<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#f2e49ec76411e4dc53376bb2bfbf1979">H2S2</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const int mu)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$H_{\mu}^2$" src="form_54.png"> Sobolev scalarproduct of two fields on sphere. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#fc3309d070ee1065ba6447c87943edf5">reflect</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reflect with respect to origin (parity operator).  <a href="#fc3309d070ee1065ba6447c87943edf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#38cd2ef7232c86c7f2960fedb1cf0da3">mulCosTheta</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)$" src="form_56.png">.  <a href="#38cd2ef7232c86c7f2960fedb1cf0da3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#cae56acc1c959249c5fde820a7db750a">mulCosThetaSqr</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)^2$" src="form_57.png">.  <a href="#cae56acc1c959249c5fde820a7db750a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#e35fe5fe1f000ff1bcaf39a941bbbdca">mulSinThetaSqr</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication operator by <img class="formulaInl" alt="$\sin(\vartheta)^2$" src="form_58.png">.  <a href="#e35fe5fe1f000ff1bcaf39a941bbbdca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#6b9ceeee206852cf3ea484a16e506ed6">partial_phi</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for real scalar field.  <a href="#6b9ceeee206852cf3ea484a16e506ed6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#f1a93dee2b7726ca194bd5cd914ee559">Sqr_partial_phi</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Second <img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for real scalar field.  <a href="#f1a93dee2b7726ca194bd5cd914ee559"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#b8dc4d2e7949f3c68b35ca137ad69f69">sinTheta_partial_theta</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$\sin(\vartheta)\partial_{\vartheta}$" src="form_61.png"> derivative on sphere for real scalar field.  <a href="#b8dc4d2e7949f3c68b35ca137ad69f69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#9992be0df6396ae55cec42aa8d68946d">partial_x</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(<img class="formulaInl" alt="$\partial_{1}(\cdot)\circ(\arccos,\mathrm{id}))\circ(\cos,\mathrm{id})$" src="form_62.png"> derivative on sphere for real scalar field.  <a href="#9992be0df6396ae55cec42aa8d68946d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#b866d07640762bc47975adddcdd8b751">LaplaceS2</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Laplace operator on unit sphere for real scalar field.  <a href="#b866d07640762bc47975adddcdd8b751"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#b1aa96b9013be0117f50f05057a9ce41">normBoundNeumann</a> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> a00, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> H2S2aa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper estimate of the <img class="formulaInl" alt="$C^{0}$" src="form_68.png"> norm of <img class="formulaInl" alt="$1 -$" src="form_69.png"> a real field for Neumann series expansion.  <a href="#b1aa96b9013be0117f50f05057a9ce41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#1c4213578c0face59aeafc6e38c24d92">optimalScalingNeumann</a> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> a00, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> H2S2aa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scaling factor <img class="formulaInl" alt="$a$" src="form_73.png">, with which <img class="formulaInl" alt="$\Vert1-a^{-1}A\Vert^2_{H_2^2}$" src="form_74.png"> is minimized for a real field <img class="formulaInl" alt="$A$" src="form_75.png"> on sphere.  <a href="#1c4213578c0face59aeafc6e38c24d92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#0ba0c41650f650e45c841937f8b8f708">divideByNeumann</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;a, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;f, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> norm, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> errortolerance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Division of a real field by a real field, using Neumann series.  <a href="#0ba0c41650f650e45c841937f8b8f708"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#25d8ca9f24435bb928b62626e077b600">tailErrorBoundS2</a> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const int mup, const int mu, int *lmax, int *mmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An upper bound for the tail sum in <img class="formulaInl" alt="$H_{\mu}^{2}$" src="form_77.png"> norm, assuming that the field is in the space <img class="formulaInl" alt="$H_{\mu'}^2$" src="form_78.png">.  <a href="#25d8ca9f24435bb928b62626e077b600"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#17c21b5e46f3ea50c4f75cffd7952974">operator+</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GComplex__t_01_4.html" title="Class for complex scalar fields on sphere.">ScalarFieldMP&lt;GComplex_t&gt;</a> algebraic operators.  <a href="#17c21b5e46f3ea50c4f75cffd7952974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="04b994699aa91f1beac38415b2b579f0"></a><!-- doxytag: member="gridripper::multipole::operator+" ref="04b994699aa91f1beac38415b2b579f0" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb2cf5df341e400bb64153e68db50bc9"></a><!-- doxytag: member="gridripper::multipole::operator+" ref="eb2cf5df341e400bb64153e68db50bc9" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9fb9f1ed503859fa9029d519de6b8a5e"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="9fb9f1ed503859fa9029d519de6b8a5e" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="88fef9c3ec1c04efa7f29b26fd47be16"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="88fef9c3ec1c04efa7f29b26fd47be16" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a477e2f0e1daf5b0dfeb1c999b6355ef"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="a477e2f0e1daf5b0dfeb1c999b6355ef" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fb951db94dd5b4bf27f430c3e1ce627"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="7fb951db94dd5b4bf27f430c3e1ce627" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7cf4048954e1911f0a7ecf43a44d4273"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="7cf4048954e1911f0a7ecf43a44d4273" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const GReal_t)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f282bd4c6f160ec26df8eba1dc1c95ef"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="f282bd4c6f160ec26df8eba1dc1c95ef" args="(const GReal_t, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1cb7bcdcd7607c49c7c2aae56523560"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="f1cb7bcdcd7607c49c7c2aae56523560" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="305884e01f802164d5b972981aa3f318"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="305884e01f802164d5b972981aa3f318" args="(const GComplex_t &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const GComplex_t &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d53c94edffc69aef03b3e37e7f7f0cb7"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="d53c94edffc69aef03b3e37e7f7f0cb7" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const GComplex_t &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa928d773c5b97c04225bf1de2280e8f"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="aa928d773c5b97c04225bf1de2280e8f" args="(const GComplex_t &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const GComplex_t &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de56df13d7316f935899a6f4e91cc709"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="de56df13d7316f935899a6f4e91cc709" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9524dca4bbb2eb34a8aed10a4e069fc4"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="9524dca4bbb2eb34a8aed10a4e069fc4" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fbb99be50b97d39eba2a4e257ac4903e"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="fbb99be50b97d39eba2a4e257ac4903e" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3c92383267d951f6caab2f0314fbe6b"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="b3c92383267d951f6caab2f0314fbe6b" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const GReal_t)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="413640a606da2521a8eb8dea9eea8f7b"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="413640a606da2521a8eb8dea9eea8f7b" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="219a72b00682da71e258fb5a112840f5"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="219a72b00682da71e258fb5a112840f5" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const GComplex_t &amp;)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const GComplex_t &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#a38a19c7cc9c05cafb30a5d95c2073b9">conj</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complex conjugate a scalarfield on sphere.  <a href="#a38a19c7cc9c05cafb30a5d95c2073b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#69299b21deea8ad6a94ffbd4172f0975">real</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real part of a scalarfield on sphere.  <a href="#69299b21deea8ad6a94ffbd4172f0975"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#127bece430576630b25b2c29daf9c643">imag</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Imaginary part of a scalarfield on sphere.  <a href="#127bece430576630b25b2c29daf9c643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#1d0d37e71e179a084b828546a4e6e899">L2S2</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">L^2 scalarproduct of fields.  <a href="#1d0d37e71e179a084b828546a4e6e899"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f195c8d336a325cfa83dcf5c0c6aa58f"></a><!-- doxytag: member="gridripper::multipole::L2S2" ref="f195c8d336a325cfa83dcf5c0c6aa58f" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>L2S2</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="80ebe3fc42f12299f1b94d8174f8f9fb"></a><!-- doxytag: member="gridripper::multipole::L2S2" ref="80ebe3fc42f12299f1b94d8174f8f9fb" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>L2S2</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="447edb873c53eb592c0e477e14a871ee"></a><!-- doxytag: member="gridripper::multipole::H2S2" ref="447edb873c53eb592c0e477e14a871ee" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;, const int mu)" -->
GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#447edb873c53eb592c0e477e14a871ee">H2S2</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const int mu)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$H_{\mu}^2$" src="form_54.png"> Sobolev scalarproduct of two fields on sphere. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23187f8a26a1f527628350a5189e5544"></a><!-- doxytag: member="gridripper::multipole::H2S2" ref="23187f8a26a1f527628350a5189e5544" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int mu)" -->
GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>H2S2</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int mu)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5128179c667350500c8045f7cbc32740"></a><!-- doxytag: member="gridripper::multipole::H2S2" ref="5128179c667350500c8045f7cbc32740" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int mu)" -->
GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>H2S2</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int mu)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#870f107e82ff6f9c581d26744d585b96">L2S2limited</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> theta, <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &gt; &gt; *coeffstorage)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$L^2$" src="form_81.png"> scalarproduct of fields, with limited integration domain to <img class="formulaInl" alt="$[0,\theta]\times[0,2\pi]$" src="form_82.png">.  <a href="#870f107e82ff6f9c581d26744d585b96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#85db116fd5c05e577a328f084b53eaa6">reflect</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reflect with respect to origin (parity operator).  <a href="#85db116fd5c05e577a328f084b53eaa6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#01543d028e956a562c9e5b26742f99fd">stepping</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int upOrDown)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stepping up and down operators.  <a href="#01543d028e956a562c9e5b26742f99fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#5665264e45afd4151d3fe11d0ffbc1d6">mulCosTheta</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)$" src="form_56.png">.  <a href="#5665264e45afd4151d3fe11d0ffbc1d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#5db3c2780b1785a53adadfd77cb567e1">mulCosThetaSqr</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)^2$" src="form_57.png">.  <a href="#5db3c2780b1785a53adadfd77cb567e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#fd575d98ab8ed41a8794ea4acdc164d7">mulSinThetaSqr</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication operator by <img class="formulaInl" alt="$\sin(\vartheta)^2$" src="form_58.png">.  <a href="#fd575d98ab8ed41a8794ea4acdc164d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#e42c7a0736abc4f6a1d2bf684c2fe957">mulExpPmIPhi</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int sign)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication operator by <img class="formulaInl" alt="$\mathrm{e}^{\pm\mathrm{i}\varphi}$" src="form_90.png">.  <a href="#e42c7a0736abc4f6a1d2bf684c2fe957"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#e225e6e76b7e345edadcd6b329935d09">partial_phi</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for complex scalar field.  <a href="#e225e6e76b7e345edadcd6b329935d09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#eed2535963dbe2006e701534b7624075">Sqr_partial_phi</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Second <img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for complex scalar field.  <a href="#eed2535963dbe2006e701534b7624075"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#e540ed68e93461e29c7a5d5d4a3269d7">sinTheta_partial_theta</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$\sin(\vartheta)\partial_{\vartheta}$" src="form_61.png"> derivative on sphere for complex scalar field.  <a href="#e540ed68e93461e29c7a5d5d4a3269d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#440b01f6df8f27a1406e2831af142c78">partial_theta</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$\partial_{\vartheta}$" src="form_94.png"> derivative on sphere for complex field.  <a href="#440b01f6df8f27a1406e2831af142c78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#dc5e96804bca73284bd38327dce3878b">partial_x</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><img class="formulaInl" alt="$(\partial_{1}(\cdot)\circ(\arccos,\mathrm{id}))\circ(\cos,\mathrm{id})$" src="form_95.png"> derivative on sphere for complex scalar field.  <a href="#dc5e96804bca73284bd38327dce3878b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#82bafa03f95496983159633e61bcee9e">LaplaceS2</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Laplace operator on unit sphere for complex scalar field.  <a href="#82bafa03f95496983159633e61bcee9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#84c887447df1a0469e71c6c94d57ef2a">normBoundNeumann</a> (const GComplex_t &amp;a00, const GComplex_t &amp;H2S2aa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper estimate of the <img class="formulaInl" alt="$C^{0}$" src="form_68.png"> norm of <img class="formulaInl" alt="$1 -$" src="form_69.png"> a complex field for Neumann series.  <a href="#84c887447df1a0469e71c6c94d57ef2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GComplex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#e53c14c8d4ebe2a8dd404fbdb4004d59">optimalScalingNeumann</a> (const GComplex_t &amp;a00, const GComplex_t &amp;H2S2aa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scaling factor <img class="formulaInl" alt="$a$" src="form_73.png">, with which <img class="formulaInl" alt="$\Vert1-a^{-1}A\Vert^2_{H_2^2}$" src="form_74.png"> is minimized for a complex field $A$ on sphere.  <a href="#e53c14c8d4ebe2a8dd404fbdb4004d59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#097b97f6b2d5ba1f3a59d6c82241defe">divideByNeumann</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;a, const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;f, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> norm, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> errortolerance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Division of a complex field by a complex field, using Neumann series.  <a href="#097b97f6b2d5ba1f3a59d6c82241defe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="616d2bf72eefaaa2d313ca604d53531c"></a><!-- doxytag: member="gridripper::multipole::divideByNeumann" ref="616d2bf72eefaaa2d313ca604d53531c" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;a, const ScalarFieldMP&lt; GComplex_t &gt; &amp;f, const GReal_t norm, const GReal_t errortolerance)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>divideByNeumann</b> (const ScalarFieldMP&lt; <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> &gt; &amp;a, const ScalarFieldMP&lt; GComplex_t &gt; &amp;f, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> norm, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> errortolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a791c689bcaedc2b52521cd9c755e37"></a><!-- doxytag: member="gridripper::multipole::divideByNeumann" ref="6a791c689bcaedc2b52521cd9c755e37" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;a, const ScalarFieldMP&lt; GComplex_t &gt; &amp;f, const GReal_t norm, const GReal_t errortolerance)" -->
ScalarFieldMP&lt; GComplex_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>divideByNeumann</b> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;a, const ScalarFieldMP&lt; GComplex_t &gt; &amp;f, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> norm, const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> errortolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#4d102e73f6012014bfd53e709aff6255">tailErrorBoundS2</a> (const ScalarFieldMP&lt; GComplex_t &gt; &amp;a, const int mup, const int mu, int *lmax, int *mmax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An upper bound for the tail sum in the <img class="formulaInl" alt="$H_{\mu}^{2}$" src="form_77.png"> norm, assuming that the field is in the space <img class="formulaInl" alt="$H_{\mu'}^{2}$" src="form_107.png">.  <a href="#4d102e73f6012014bfd53e709aff6255"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="852242a74fabf194813daacdd4253a9d"></a><!-- doxytag: member="gridripper::multipole::maxEval" ref="852242a74fabf194813daacdd4253a9d" args="(const unsigned int)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#852242a74fabf194813daacdd4253a9d">maxEval</a> (const unsigned int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integration error tolerance parameters for functional field expansion by AGM routine. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46054a64d1f35b70fcfa569cc30f18b3"></a><!-- doxytag: member="gridripper::multipole::maxEval" ref="46054a64d1f35b70fcfa569cc30f18b3" args="()" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>maxEval</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c41a1394d13ffa3605a068083a50c7ff"></a><!-- doxytag: member="gridripper::multipole::reqAbsError" ref="c41a1394d13ffa3605a068083a50c7ff" args="(const GReal_t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reqAbsError</b> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b91e13519e537041eb80902331375fd3"></a><!-- doxytag: member="gridripper::multipole::reqAbsError" ref="b91e13519e537041eb80902331375fd3" args="()" -->
<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>reqAbsError</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0392fb1338d87b9f4ee995ef8766f04"></a><!-- doxytag: member="gridripper::multipole::reqRelError" ref="b0392fb1338d87b9f4ee995ef8766f04" args="(const GReal_t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reqRelError</b> (const <a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc0f65a185caa502d8e8b8086750abb6"></a><!-- doxytag: member="gridripper::multipole::reqRelError" ref="fc0f65a185caa502d8e8b8086750abb6" args="()" -->
<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>reqRelError</b> ()</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b03148bb591d396714d8ccf9e8d6d20e"></a><!-- doxytag: member="gridripper::multipole::SobolevOrderS2" ref="b03148bb591d396714d8ccf9e8d6d20e" args="" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegridripper_1_1multipole.html#b03148bb591d396714d8ccf9e8d6d20e">SobolevOrderS2</a> = 1000000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximal series expansion order for the numerical calculation of Sobolev related constants over the sphere. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Multipole expansion classes and methods. <hr><h2>Function Documentation</h2>
<a class="anchor" name="a38a19c7cc9c05cafb30a5d95c2073b9"></a><!-- doxytag: member="gridripper::multipole::conj" ref="a38a19c7cc9c05cafb30a5d95c2073b9" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::conj           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Complex conjugate a scalarfield on sphere. 
<p>
Based on: <img class="formulaInl" alt="$\bar{Y}_{l}^{m} = (-1)^{m} Y_{l}^{-m}$" src="form_79.png">. 
</div>
</div><p>
<a class="anchor" name="69a213fe40035e4c164b09f60acadbcd"></a><!-- doxytag: member="gridripper::multipole::conj" ref="69a213fe40035e4c164b09f60acadbcd" args="(const Y &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;GComplex_t&gt; gridripper::multipole::conj           </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Complex conjugate a coefficient. 
<p>

</div>
</div><p>
<a class="anchor" name="097b97f6b2d5ba1f3a59d6c82241defe"></a><!-- doxytag: member="gridripper::multipole::divideByNeumann" ref="097b97f6b2d5ba1f3a59d6c82241defe" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;a, const ScalarFieldMP&lt; GReal_t &gt; &amp;f, const GReal_t norm, const GReal_t errortolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::divideByNeumann           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>errortolerance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Division of a complex field by a complex field, using Neumann series. 
<p>
Based on: <img class="formulaInl" alt="$\sum_{n=0}^{N} (I-A)^{n} A = I - (I-A)^{N+1}$" src="form_100.png">, where <img class="formulaInl" alt="$I$" src="form_101.png"> is the identity operator and <img class="formulaInl" alt="$A$" src="form_75.png"> is such an operator that <img class="formulaInl" alt="$Ran(A)\in Dom(A)$" src="form_102.png">. Specially, if <img class="formulaInl" alt="$A$" src="form_75.png"> is continuous, then it is absolute convergent if and only if <img class="formulaInl" alt="$\Vert I-A\Vert<1$" src="form_103.png">, furthermore <img class="formulaInl" alt="$\Vert I - \sum_{n=0}^{N} (I-A)^{n} A\Vert \leq \Vert I-A\Vert^{N+1}$" src="form_104.png">. If <img class="formulaInl" alt="$A$" src="form_75.png"> is a multiplication by a measurable function <img class="formulaInl" alt="$a$" src="form_73.png">, then equality holds instead of inequality, and <img class="formulaInl" alt="$\Vert I-A\Vert^{N+1} = (\mathrm{ess-sup}|1-a|)^{N+1}$" src="form_105.png">.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>: the field, which is in the nominator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>: the field to be divided </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm</em>&nbsp;</td><td>: an estimate for the essential supremum of <img class="formulaInl" alt="$|1-a|$" src="form_106.png"> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tolerance</em>&nbsp;</td><td>: an error tolarance </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>f/a : up to the specified error tolerance </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ba0c41650f650e45c841937f8b8f708"></a><!-- doxytag: member="gridripper::multipole::divideByNeumann" ref="0ba0c41650f650e45c841937f8b8f708" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;a, const ScalarFieldMP&lt; GReal_t &gt; &amp;f, const GReal_t norm, const GReal_t errortolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::divideByNeumann           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>errortolerance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Division of a real field by a real field, using Neumann series. 
<p>
Based on: same rule as for complex. 
</div>
</div><p>
<a class="anchor" name="e876b678b59e8d1a161641a2c2d40072"></a><!-- doxytag: member="gridripper::multipole::ExpPmIPhiYY_coupling" ref="e876b678b59e8d1a161641a2c2d40072" args="(const int l1, const int m1, const int l2, const int sign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::ExpPmIPhiYY_coupling           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The overlap integrals <img class="formulaInl" alt="$\int_{0}^{\pi}\int_{0}^{2\pi} \mathrm{e}^{\pm\mathrm{i}\varphi} Y_{l_1}^{m_1}(\vartheta, \varphi) Y_{l_2}^{-(m_1\pm1)}(\vartheta, \varphi) \;\sin(\vartheta)\mathrm{d}\vartheta\,\mathrm{d}\varphi$" src="form_35.png">. 
<p>
Based on: idea from J. Phys. A31 (1998) 1101, and J. Phys. A32 (1999) 2601, and J. Phys. A35 (2002) 4187. Namely, on expanding of products of Y-s by Gaunt coefficients <img class="formulaInl" alt="$G$" src="form_36.png">. <img class="formulaInl" alt="$\int_{0}^{\pi}\int_{0}^{2\pi} \mathrm{e}^{\pm\mathrm{i}\varphi} Y_{l_1}^{m_1}(\vartheta, \varphi) Y_{l_2}^{-(m_1\pm1)}(\vartheta, \varphi) \;\sin(\vartheta)\mathrm{d}\vartheta\,\mathrm{d}\varphi = \sum_{k=0}^{\min(l_1,l_2)} \pm G^{m_1,-(m_1\pm1),\pm1}_{l_1,l_2,|l_1-l_2|+2k} \int_{0}^{\pi}\int_{0}^{2\pi} Y^{1}_{|l_1-l_2|+2k}(\vartheta, \varphi) \exp(-\mathrm{i}\varphi) \;\sin{\vartheta}\mathrm{d}\vartheta\,\mathrm{d}\varphi$" src="form_37.png">. This quantity is zero for: 1) <img class="formulaInl" alt="$l_1<0$" src="form_38.png"> or <img class="formulaInl" alt="$l_2<0$" src="form_39.png">, 2) <img class="formulaInl" alt="$|m_1|>l_1$" src="form_40.png"> or <img class="formulaInl" alt="$|m_1\pm1|>l_2$" src="form_41.png">, 3) <img class="formulaInl" alt="$l_1+l_2$" src="form_42.png"> even.<p>
Numerically verified using a Maple code.<p>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.5, 04/01/2008 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GridRipper 0.5 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andras Laszlo </dd></dl>

</div>
</div><p>
<a class="anchor" name="b75f0e976ae2d1526f2ba013e828c02f"></a><!-- doxytag: member="gridripper::multipole::ExpPmIPhiYY_coupling_size" ref="b75f0e976ae2d1526f2ba013e828c02f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gridripper::multipole::ExpPmIPhiYY_coupling_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show table size currently used in ExpPmIPhiYY_coupling. 
<p>

</div>
</div><p>
<a class="anchor" name="127bece430576630b25b2c29daf9c643"></a><!-- doxytag: member="gridripper::multipole::imag" ref="127bece430576630b25b2c29daf9c643" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::imag           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Imaginary part of a scalarfield on sphere. 
<p>

</div>
</div><p>
<a class="anchor" name="9024b80824536167ace62ed4574ad0ec"></a><!-- doxytag: member="gridripper::multipole::intBarYl1mYl2m" ref="9024b80824536167ace62ed4574ad0ec" args="(const int l1, const int l2, const int m, const GReal_t theta, tvector&lt; tvector&lt; tvector&lt; GReal_t &gt; &gt; &gt; *coeffstorage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::intBarYl1mYl2m           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; GReal_t &gt; &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>coeffstorage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculation of <img class="formulaInl" alt="$\int_{[0,\theta]\times[0,2\pi]} \bar{Y}_{l_1}^{m} Y_{l_2}^{m} \;\mathrm{d}\lambda_{S^2}$" src="form_46.png">. 
<p>
Based on: expansion of <img class="formulaInl" alt="$\bar{Y}_{l_1}^{m}Y_{l_2}^{m}$" src="form_47.png"> product by using Gaunt coefficients. Result: <img class="formulaInl" alt="$\int_{[0,\theta]\times[0,2\pi]} \bar{Y}_{l_1}^{m} Y_{l_2}^{m} \;\mathrm{d}\lambda_{S^2} = (-1)^{m} \sum_{k=0}^{\min(l_1, l_2)} G_{l_1,l_2,|l_1-l_2|+|l_1-l_2|\%2+2k}^{-m,m,0} \int_{[0,\theta]\times[0,2\pi]} Y_{|l_1-l_2|+|l_1-l_2|\%2+2k}^{0} \;\mathrm{d}\lambda_{S^2}$" src="form_48.png">, <img class="formulaInl" alt="$G$" src="form_36.png"> being the Gaunt coefficients.<p>
To avoid expensive evaluation, a table is stored (appended) to 'coeffstorage'. Initially should be empty, and should be different for every '<img class="formulaInl" alt="$\theta$" src="form_49.png">'. If the pointer to 'coeffstorage' is NULL, the coefficients are not stored, but calculated each time.<p>
Numerically verified using Maple.<p>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.5, 22/07/2008 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GridRipper 0.5 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andras Laszlo </dd></dl>

</div>
</div><p>
<a class="anchor" name="5bed2f2660f11bb006c18fd66217a79d"></a><!-- doxytag: member="gridripper::multipole::intYl0" ref="5bed2f2660f11bb006c18fd66217a79d" args="(const int l, const GReal_t theta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::intYl0           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>theta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculation of <img class="formulaInl" alt="$\int_{[0,\theta]\times[0,2\pi]} Y_{l}^{0} \;\mathrm{d}\lambda_{S^2}$" src="form_43.png">. 
<p>
Based on: <img class="formulaInl" alt="$P_{l+1}^{0'}-P_{l-1}^{0'} = (2l+1) P_{l}^{0}$" src="form_44.png"> (from Journal of Modern Optics 36 (1989) 685, but may be easily verified from Rodriguez formula). Result is: <img class="formulaInl" alt="$\int_{[0,\theta]\times[0,2\pi]} Y_{l}^{0} \;\mathrm{d}\lambda_{S^2} = 2\pi ( \frac{1}{\sqrt{4\pi}}\delta_{l,0} - \frac{1}{\sqrt{(2l+1)(2l+3)}}Y_{l+1}^{0}(\theta, 0) + \frac{1}{\sqrt{(2l-1)(2l+1)}}Y_{l-1}^{0}(\theta, 0) )$" src="form_45.png">.<p>
Numerically verified using Maple.<p>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.5, 22/07/2008 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GridRipper 0.5 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andras Laszlo </dd></dl>

</div>
</div><p>
<a class="anchor" name="c7dd8c132463b0ee92c42dee0141de79"></a><!-- doxytag: member="gridripper::multipole::intYl1ExpMIPhi" ref="c7dd8c132463b0ee92c42dee0141de79" args="(const int l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::intYl1ExpMIPhi           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculation of <img class="formulaInl" alt="$\int_{0}^{2\pi}\int_{0}^{\pi} Y_{l}^{1}(\vartheta, \varphi) \exp(-\mathrm{i}\varphi) \sin(\vartheta)\;\mathrm{d}\vartheta\,\mathrm{d}\varphi$" src="form_31.png">. 
<p>
Based on: formula in J. Phys. A32 (1999) 2601. Namely: <img class="formulaInl" alt="$\int_{-1}^{1} P^{1}_{l}(x) \;\mathrm{d}x = \frac{(-1)^{l}-1}{2} \frac{l}{l+1} \left(\frac{\Gamma(l/2)}{((l-1)/2)!}\right)^{2} = \frac{(-1)^{l}-1}{2} \pi \frac{l}{l+1} \left(\prod_{k=1}^{(l-1)/2} \frac{l/2-k}{(l+1)/2-k}\right)^{2} = \frac{(-1)^{l}-1}{2} \pi \frac{l}{l+1} \prod_{n=1}^{(l-1)/2} \left(\frac{n-1/2}{n}\right)^{2}$" src="form_32.png"> delivers final result (which is zero for even <img class="formulaInl" alt="$l$" src="form_33.png">). Thus: <img class="formulaInl" alt="$\int_{0}^{2\pi}\int_{0}^{\pi} Y_{l}^{1}(\vartheta, \varphi) \exp(-\mathrm{i}\varphi) \sin(\vartheta)\;\mathrm{d}\vartheta\,\mathrm{d}\varphi = \frac{(-1)^{l}-1}{2} \sqrt{\pi^{3} \frac{l(2l+1)}{(l+1)^{3}}} \prod_{n=1}^{(l-1)/2} \left(\frac{n-1/2}{n}\right)^{2}$" src="form_34.png"> delivers final result (which is zero for even <img class="formulaInl" alt="$l$" src="form_33.png">).<p>
Numerically verified using a Maple and Mathematica code.<p>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.5, 04/01/2008 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GridRipper 0.5 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andras Laszlo </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d0d37e71e179a084b828546a4e6e899"></a><!-- doxytag: member="gridripper::multipole::L2S2" ref="1d0d37e71e179a084b828546a4e6e899" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GComplex_t gridripper::multipole::L2S2           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
L^2 scalarproduct of fields. 
<p>
Based on: <img class="formulaInl" alt="$\int_{0}^{\pi}\int_{0}^{2\pi} \bar{Y_{l_1}^{m_1}(\vartheta,\varphi)} Y_{l_2}^{m_2}(\vartheta,\varphi) \;\sin(\vartheta)\mathrm{d}\vartheta\,\mathrm{d}\varphi = \delta_{l_1, l_2}\delta_{m_1, m_2}$" src="form_80.png">. 
</div>
</div><p>
<a class="anchor" name="cfbe86f5ff178b8fde432b8f22df0e4d"></a><!-- doxytag: member="gridripper::multipole::L2S2" ref="cfbe86f5ff178b8fde432b8f22df0e4d" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::L2S2           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
L^2 scalarproduct of two fields on sphere. 
<p>
Based on: <img class="formulaInl" alt="$\int_{0}^{\pi}\int_{0}^{2\pi} Yre_{l_1}^{m_1}(\vartheta,\varphi) Yre_{l_2}^{m_2}(\vartheta,\varphi) \;\sin(\vartheta)\mathrm{d}\vartheta\,\mathrm{d}\varphi = \delta_{l_1, l_2}\delta_{m_1, m_2}$" src="form_53.png">. 
</div>
</div><p>
<a class="anchor" name="870f107e82ff6f9c581d26744d585b96"></a><!-- doxytag: member="gridripper::multipole::L2S2limited" ref="870f107e82ff6f9c581d26744d585b96" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const GReal_t theta, tvector&lt; tvector&lt; tvector&lt; GReal_t &gt; &gt; &gt; *coeffstorage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GComplex_t gridripper::multipole::L2S2limited           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; <a class="el" href="classtvector.html">tvector</a>&lt; GReal_t &gt; &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>coeffstorage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<img class="formulaInl" alt="$L^2$" src="form_81.png"> scalarproduct of fields, with limited integration domain to <img class="formulaInl" alt="$[0,\theta]\times[0,2\pi]$" src="form_82.png">. 
<p>
Based on the Gaunt expansion of spherical harmonic products. (See <a class="el" href="Gaunt_8h-source.html">Gaunt.h</a> and Gaunt.cxx.) The necessary coefficient matrix is stored (appended) to 'coeffstorage', for a given '<img class="formulaInl" alt="$\vartheta$" src="form_8.png">'. Should be empty initially for a given '<img class="formulaInl" alt="$\vartheta$" src="form_8.png">'. If the pointer to 'coeffstorage' is NULL, the coefficient matrix is not stored in table, but calculated every time. 
</div>
</div><p>
<a class="anchor" name="82bafa03f95496983159633e61bcee9e"></a><!-- doxytag: member="gridripper::multipole::LaplaceS2" ref="82bafa03f95496983159633e61bcee9e" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::LaplaceS2           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Laplace operator on unit sphere for complex scalar field. 
<p>
Based on: <img class="formulaInl" alt="$(\frac{1}{\sin(\vartheta)}\partial_{\vartheta}\sin(\vartheta)\partial_{\vartheta} + \frac{1}{\sin^{2}(\vartheta)}\partial_{\varphi}\partial_{\varphi}) Y_{l}^{m} = -l(l+1) Y_{l}^{m}$" src="form_99.png">. 
</div>
</div><p>
<a class="anchor" name="b866d07640762bc47975adddcdd8b751"></a><!-- doxytag: member="gridripper::multipole::LaplaceS2" ref="b866d07640762bc47975adddcdd8b751" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::LaplaceS2           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Laplace operator on unit sphere for real scalar field. 
<p>
Based on: <img class="formulaInl" alt="$(\frac{1}{\sin(\vartheta)}\partial_{\vartheta}\sin(\vartheta)\partial_{\vartheta} + \frac{1}{\sin^{2}(\vartheta)}\partial_{\varphi}\partial_{\varphi}) Yre_{l}^{m} = -l(l+1) Yre_{l}^{m}$" src="form_67.png">. 
</div>
</div><p>
<a class="anchor" name="5665264e45afd4151d3fe11d0ffbc1d6"></a><!-- doxytag: member="gridripper::multipole::mulCosTheta" ref="5665264e45afd4151d3fe11d0ffbc1d6" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::mulCosTheta           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)$" src="form_56.png">. 
<p>
Based on: <img class="formulaInl" alt="$\cos(\vartheta) Y_{l}^{m} = \sqrt{\frac{(l-m)(l+m)}{(2l-1)(2l+1)}} Y_{l-1}^{m} + + \sqrt{\frac{(l+1-m)(l+1+m)}{(2l+1)(2l+3)}} Y_{l+1}^{m}$" src="form_88.png">. Numerically verified by a C++ code. 
</div>
</div><p>
<a class="anchor" name="38cd2ef7232c86c7f2960fedb1cf0da3"></a><!-- doxytag: member="gridripper::multipole::mulCosTheta" ref="38cd2ef7232c86c7f2960fedb1cf0da3" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::mulCosTheta           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)$" src="form_56.png">. 
<p>
Based on the rule for <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a> basis. Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="5db3c2780b1785a53adadfd77cb567e1"></a><!-- doxytag: member="gridripper::multipole::mulCosThetaSqr" ref="5db3c2780b1785a53adadfd77cb567e1" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::mulCosThetaSqr           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)^2$" src="form_57.png">. 
<p>
Based on: <img class="formulaInl" alt="$\cos(\vartheta)^{2} Y_{l}^{m} = \sqrt{\frac{(l-1-m)(l-m)(l-1+m)(l+m)} {(2l-3)(2l-1)(2l-1)(2l+1)}} Y_{l-2}^{m} + \left(\frac{(l-m)(l+m)}{(2l-1)(2l+1)}+\frac{(l+1-m)(l+1+m)}{(2l+1)(2l+3)}\right) Y_{l}^{m} + \sqrt{\frac{(l+1-m)(l+2-m)(l+1+m)(l+2+m)} {(2l+1)(2l+3)(2l+3)(2l+5)}} Y_{l+2}^{m}$" src="form_89.png">. Numerically verified by a C++ code. 
</div>
</div><p>
<a class="anchor" name="cae56acc1c959249c5fde820a7db750a"></a><!-- doxytag: member="gridripper::multipole::mulCosThetaSqr" ref="cae56acc1c959249c5fde820a7db750a" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::mulCosThetaSqr           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication operator by <img class="formulaInl" alt="$\cos(\vartheta)^2$" src="form_57.png">. 
<p>
Based on the rule for <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a> basis. Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="e42c7a0736abc4f6a1d2bf684c2fe957"></a><!-- doxytag: member="gridripper::multipole::mulExpPmIPhi" ref="e42c7a0736abc4f6a1d2bf684c2fe957" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int sign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::mulExpPmIPhi           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication operator by <img class="formulaInl" alt="$\mathrm{e}^{\pm\mathrm{i}\varphi}$" src="form_90.png">. 
<p>
Based on: matrix elements is <a class="el" href="Gaunt_8h-source.html">Gaunt.h</a>, Gaunt.cxx. Numerically verified by a Maple code. 
</div>
</div><p>
<a class="anchor" name="fd575d98ab8ed41a8794ea4acdc164d7"></a><!-- doxytag: member="gridripper::multipole::mulSinThetaSqr" ref="fd575d98ab8ed41a8794ea4acdc164d7" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::mulSinThetaSqr           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication operator by <img class="formulaInl" alt="$\sin(\vartheta)^2$" src="form_58.png">. 
<p>
Based on: <img class="formulaInl" alt="$\cos(\vartheta)^2$" src="form_57.png">. Numerically verified by a C++ code. 
</div>
</div><p>
<a class="anchor" name="e35fe5fe1f000ff1bcaf39a941bbbdca"></a><!-- doxytag: member="gridripper::multipole::mulSinThetaSqr" ref="e35fe5fe1f000ff1bcaf39a941bbbdca" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::mulSinThetaSqr           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication operator by <img class="formulaInl" alt="$\sin(\vartheta)^2$" src="form_58.png">. 
<p>
Based on: <img class="formulaInl" alt="$\cos(\vartheta)^2$" src="form_57.png">. Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="84c887447df1a0469e71c6c94d57ef2a"></a><!-- doxytag: member="gridripper::multipole::normBoundNeumann" ref="84c887447df1a0469e71c6c94d57ef2a" args="(const GComplex_t &amp;a00, const GComplex_t &amp;H2S2aa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::normBoundNeumann           </td>
          <td>(</td>
          <td class="paramtype">const GComplex_t &amp;&nbsp;</td>
          <td class="paramname"> <em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GComplex_t &amp;&nbsp;</td>
          <td class="paramname"> <em>H2S2aa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Upper estimate of the <img class="formulaInl" alt="$C^{0}$" src="form_68.png"> norm of <img class="formulaInl" alt="$1 -$" src="form_69.png"> a complex field for Neumann series. 
<p>
Based on: the Sobolev inequality, namely <img class="formulaInl" alt="$\Vert\cdot\Vert_{C^{0}} \leq C\Vert\cdot\Vert_{H_2^2}$" src="form_71.png">.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a00</em>&nbsp;</td><td>: the (0, 0) <a class="el" href="namespacegridripper_1_1multipole.html" title="Multipole expansion classes and methods.">multipole</a> component of the field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>H2S2aa</em>&nbsp;</td><td>: the <img class="formulaInl" alt="$\left<a, a\right>_{H_2^2}$" src="form_72.png"> scalar product </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b1aa96b9013be0117f50f05057a9ce41"></a><!-- doxytag: member="gridripper::multipole::normBoundNeumann" ref="b1aa96b9013be0117f50f05057a9ce41" args="(const GReal_t a00, const GReal_t H2S2aa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::normBoundNeumann           </td>
          <td>(</td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>H2S2aa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Upper estimate of the <img class="formulaInl" alt="$C^{0}$" src="form_68.png"> norm of <img class="formulaInl" alt="$1 -$" src="form_69.png"> a real field for Neumann series expansion. 
<p>
Based on: the <img class="formulaInl" alt="$H_2^2$" src="form_70.png"> Sobolev inequality, namely <img class="formulaInl" alt="$\Vert\cdot\Vert_{C^{0}} \leq C\Vert\cdot\Vert_{H_2^2}$" src="form_71.png">.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a00</em>&nbsp;</td><td>: the (0, 0) <a class="el" href="namespacegridripper_1_1multipole.html" title="Multipole expansion classes and methods.">multipole</a> component of the field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>H2S2aa</em>&nbsp;</td><td>: the <img class="formulaInl" alt="$\left<a, a\right>_{H_2^2}$" src="form_72.png"> scalar product </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="93b2dbce3fff7b5f6fef3838f6f6eb17"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="93b2dbce3fff7b5f6fef3838f6f6eb17" args="(const GReal_t, const Coeff&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;GComplex_t&gt; gridripper::multipole::operator*           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coeff&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a coefficient by a number. 
<p>

</div>
</div><p>
<a class="anchor" name="7a6c723945acb12cf72b377a85387571"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="7a6c723945acb12cf72b377a85387571" args="(const GReal_t, const Y &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;GComplex_t&gt; gridripper::multipole::operator*           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tensor product of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="2e16ce21df912ed1b9a964121bd12cc3"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="2e16ce21df912ed1b9a964121bd12cc3" args="(const GReal_t, const Coeff&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::operator*           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coeff&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a coefficient by a number. 
<p>

</div>
</div><p>
<a class="anchor" name="f12d46f0a50e3f65b5f7fcfa4b55da02"></a><!-- doxytag: member="gridripper::multipole::operator*" ref="f12d46f0a50e3f65b5f7fcfa4b55da02" args="(const GReal_t, const Yre &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::operator*           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Yre &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tensor product of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="17c21b5e46f3ea50c4f75cffd7952974"></a><!-- doxytag: member="gridripper::multipole::operator+" ref="17c21b5e46f3ea50c4f75cffd7952974" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::operator+           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GComplex__t_01_4.html" title="Class for complex scalar fields on sphere.">ScalarFieldMP&lt;GComplex_t&gt;</a> algebraic operators. 
<p>

</div>
</div><p>
<a class="anchor" name="67683cdbcc011c89273e6cd16dcb09f5"></a><!-- doxytag: member="gridripper::multipole::operator+" ref="67683cdbcc011c89273e6cd16dcb09f5" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::operator+           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classgridripper_1_1multipole_1_1ScalarFieldMP_3_01GReal__t_01_4.html" title="Class for real scalar fields on sphere.">ScalarFieldMP&lt;GReal_t&gt;</a> algebraic operators. 
<p>

</div>
</div><p>
<a class="anchor" name="748b9a50c76550f6c74d8b1203d4ae81"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="748b9a50c76550f6c74d8b1203d4ae81" args="(const Y &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;GComplex_t&gt; gridripper::multipole::operator-           </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Negative of a coefficient. 
<p>

</div>
</div><p>
<a class="anchor" name="b96dfe1a6cd2d3a68675c67869571604"></a><!-- doxytag: member="gridripper::multipole::operator-" ref="b96dfe1a6cd2d3a68675c67869571604" args="(const Yre &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::operator-           </td>
          <td>(</td>
          <td class="paramtype">const Yre &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Negative of a coefficient. 
<p>

</div>
</div><p>
<a class="anchor" name="232340cab0325ce3b17e92c3bbcbee79"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="232340cab0325ce3b17e92c3bbcbee79" args="(const Coeff&lt; GComplex_t &gt; &amp;, const GReal_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;GComplex_t&gt; gridripper::multipole::operator/           </td>
          <td>(</td>
          <td class="paramtype">const Coeff&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Divide a coefficient by a number. 
<p>

</div>
</div><p>
<a class="anchor" name="7937b30ef8c8948a79875c7f7d6c8c48"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="7937b30ef8c8948a79875c7f7d6c8c48" args="(const Y &amp;, const GReal_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;GComplex_t&gt; gridripper::multipole::operator/           </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tensor quotient of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="1646ea6267e2dc583778d380da0455e0"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="1646ea6267e2dc583778d380da0455e0" args="(const Coeff&lt; GReal_t &gt; &amp;, const GReal_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::operator/           </td>
          <td>(</td>
          <td class="paramtype">const Coeff&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Divide a coefficient by a number. 
<p>

</div>
</div><p>
<a class="anchor" name="b24502a97a729ab064db028f94ad90d2"></a><!-- doxytag: member="gridripper::multipole::operator/" ref="b24502a97a729ab064db028f94ad90d2" args="(const Yre &amp;, const GReal_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coeff&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::operator/           </td>
          <td>(</td>
          <td class="paramtype">const Yre &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>GReal_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tensor quotient of a number and an <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="e53c14c8d4ebe2a8dd404fbdb4004d59"></a><!-- doxytag: member="gridripper::multipole::optimalScalingNeumann" ref="e53c14c8d4ebe2a8dd404fbdb4004d59" args="(const GComplex_t &amp;a00, const GComplex_t &amp;H2S2aa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GComplex_t gridripper::multipole::optimalScalingNeumann           </td>
          <td>(</td>
          <td class="paramtype">const GComplex_t &amp;&nbsp;</td>
          <td class="paramname"> <em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GComplex_t &amp;&nbsp;</td>
          <td class="paramname"> <em>H2S2aa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scaling factor <img class="formulaInl" alt="$a$" src="form_73.png">, with which <img class="formulaInl" alt="$\Vert1-a^{-1}A\Vert^2_{H_2^2}$" src="form_74.png"> is minimized for a complex field $A$ on sphere. 
<p>
It is: <img class="formulaInl" alt="$a=\frac{\Vert A\Vert^{2}_{H_2^2}}{\sqrt{4\pi}|A_{0}^{0}|^{2}}A_{0}^{0}$" src="form_76.png">.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a00</em>&nbsp;</td><td>: the (0, 0) <a class="el" href="namespacegridripper_1_1multipole.html" title="Multipole expansion classes and methods.">multipole</a> component of the field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>H2S2aa</em>&nbsp;</td><td>: the <img class="formulaInl" alt="$\left<a, a\right>_{H_2^2}$" src="form_72.png"> scalar product </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1c4213578c0face59aeafc6e38c24d92"></a><!-- doxytag: member="gridripper::multipole::optimalScalingNeumann" ref="1c4213578c0face59aeafc6e38c24d92" args="(const GReal_t a00, const GReal_t H2S2aa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::optimalScalingNeumann           </td>
          <td>(</td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GReal_t&nbsp;</td>
          <td class="paramname"> <em>H2S2aa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scaling factor <img class="formulaInl" alt="$a$" src="form_73.png">, with which <img class="formulaInl" alt="$\Vert1-a^{-1}A\Vert^2_{H_2^2}$" src="form_74.png"> is minimized for a real field <img class="formulaInl" alt="$A$" src="form_75.png"> on sphere. 
<p>
It is: <img class="formulaInl" alt="$a=\frac{\Vert A\Vert^{2}_{H_2^2}}{\sqrt{4\pi}|A_{0}^{0}|^{2}}A_{0}^{0}$" src="form_76.png">.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a00</em>&nbsp;</td><td>: the (0, 0) <a class="el" href="namespacegridripper_1_1multipole.html" title="Multipole expansion classes and methods.">multipole</a> component of the field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>H2S2aa</em>&nbsp;</td><td>: the <img class="formulaInl" alt="$\left<a, a\right>_{H_2^2}$" src="form_72.png"> scalar product </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e225e6e76b7e345edadcd6b329935d09"></a><!-- doxytag: member="gridripper::multipole::partial_phi" ref="e225e6e76b7e345edadcd6b329935d09" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::partial_phi           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for complex scalar field. 
<p>
Based on: <img class="formulaInl" alt="$\partial_{\varphi} Y_{l}^{m} = \mathrm{i}m Y_{l}^{m}$" src="form_91.png">. 
</div>
</div><p>
<a class="anchor" name="6b9ceeee206852cf3ea484a16e506ed6"></a><!-- doxytag: member="gridripper::multipole::partial_phi" ref="6b9ceeee206852cf3ea484a16e506ed6" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::partial_phi           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for real scalar field. 
<p>
Based on: <img class="formulaInl" alt="$\partial_{\varphi} Yre_{l}^{m} = -m Yre_{l}^{-m}$" src="form_59.png">. 
</div>
</div><p>
<a class="anchor" name="440b01f6df8f27a1406e2831af142c78"></a><!-- doxytag: member="gridripper::multipole::partial_theta" ref="440b01f6df8f27a1406e2831af142c78" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::partial_theta           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<img class="formulaInl" alt="$\partial_{\vartheta}$" src="form_94.png"> derivative on sphere for complex field. 
<p>
Based on the stepping operators and on the matrix elements of the multiplication operator by <img class="formulaInl" alt="$\mathrm{e}^{\pm\mathrm{i}\varphi}$" src="form_90.png"> (<a class="el" href="Gaunt_8h-source.html">Gaunt.h</a> and Gaunt.cxx). Numerically verified by a Maple code. 
</div>
</div><p>
<a class="anchor" name="dc5e96804bca73284bd38327dce3878b"></a><!-- doxytag: member="gridripper::multipole::partial_x" ref="dc5e96804bca73284bd38327dce3878b" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::partial_x           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<img class="formulaInl" alt="$(\partial_{1}(\cdot)\circ(\arccos,\mathrm{id}))\circ(\cos,\mathrm{id})$" src="form_95.png"> derivative on sphere for complex scalar field. 
<p>
('<img class="formulaInl" alt="$x$" src="form_63.png">'-derivative, <img class="formulaInl" alt="$x=\cos(\vartheta)$" src="form_64.png">.) From Journal of Modern Optics 36 (1989) 685: <img class="formulaInl" alt="$P_{l+1}^{0'}-P_{l-1}^{0'} = (2l+1) P_{l}^{0}$" src="form_44.png"> (easily verified from Rodriguez formula). Thus: <img class="formulaInl" alt="$P_{l}^{0'} = \sum_{k=0}^{(l-l\%2)/2-(1-l\%2)} (2(2k+(1-l\%2))+1) P_{2k+(1-l\%2)}^{0}$" src="form_96.png">. Thus: <img class="formulaInl" alt="$(\partial_{1} Y_{l}^{0}\circ(\arccos,\mathrm{id}))\circ(\cos,\mathrm{id}) = (\sqrt{2l+1} \sum_{k=0}^{(l-l\%2)/2-(1-l\%2)} \sqrt{2(2k+(1-l\%2))+1} Y_{2k+(1-l\%2)}^{0})$" src="form_97.png">. Not implemented for <img class="formulaInl" alt="$m\neq0$" src="form_65.png">. Not even all <img class="formulaInl" alt="$Y_{l}^{m}$" src="form_98.png"> is in its domain in the <img class="formulaInl" alt="$L^2$" src="form_81.png"> sense. Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="9992be0df6396ae55cec42aa8d68946d"></a><!-- doxytag: member="gridripper::multipole::partial_x" ref="9992be0df6396ae55cec42aa8d68946d" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::partial_x           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
(<img class="formulaInl" alt="$\partial_{1}(\cdot)\circ(\arccos,\mathrm{id}))\circ(\cos,\mathrm{id})$" src="form_62.png"> derivative on sphere for real scalar field. 
<p>
('<img class="formulaInl" alt="$x$" src="form_63.png">'-derivative, <img class="formulaInl" alt="$x=\cos(\vartheta)$" src="form_64.png">.) Based on the rule for <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a> basis. Not implemented for <img class="formulaInl" alt="$m\neq0$" src="form_65.png">. Not even all <img class="formulaInl" alt="$Yre_{l}^{m}$" src="form_66.png"> is in its domain in the L^2 sense if <img class="formulaInl" alt="$m\neq0$" src="form_65.png">. Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="69299b21deea8ad6a94ffbd4172f0975"></a><!-- doxytag: member="gridripper::multipole::real" ref="69299b21deea8ad6a94ffbd4172f0975" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::real           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Real part of a scalarfield on sphere. 
<p>

</div>
</div><p>
<a class="anchor" name="85db116fd5c05e577a328f084b53eaa6"></a><!-- doxytag: member="gridripper::multipole::reflect" ref="85db116fd5c05e577a328f084b53eaa6" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::reflect           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reflect with respect to origin (parity operator). 
<p>
Based on: <img class="formulaInl" alt="$P Y_{l}^{m} = (-1)^{l} Y_{l}^{m}$" src="form_83.png">. 
</div>
</div><p>
<a class="anchor" name="fc3309d070ee1065ba6447c87943edf5"></a><!-- doxytag: member="gridripper::multipole::reflect" ref="fc3309d070ee1065ba6447c87943edf5" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::reflect           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reflect with respect to origin (parity operator). 
<p>
Based on: <img class="formulaInl" alt="$P Yre_{l}^{m} = (-1)^{l} Yre_{l}^{m}$" src="form_55.png">. 
</div>
</div><p>
<a class="anchor" name="e540ed68e93461e29c7a5d5d4a3269d7"></a><!-- doxytag: member="gridripper::multipole::sinTheta_partial_theta" ref="e540ed68e93461e29c7a5d5d4a3269d7" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::sinTheta_partial_theta           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<img class="formulaInl" alt="$\sin(\vartheta)\partial_{\vartheta}$" src="form_61.png"> derivative on sphere for complex scalar field. 
<p>
Based on: <img class="formulaInl" alt="$-\sin(\vartheta)\partial_{\vartheta} Y_{l}^{m} = (l+1)\sqrt{\frac{(l-m)(l+m)}{(2l-1)(2l+1)}} Y_{l-1}^{m} - l\sqrt{\frac{(l+1-m)(l+1+m)}{(2l+1)(2l+3)}} Y_{l+1}^{m}$" src="form_93.png">. Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="b8dc4d2e7949f3c68b35ca137ad69f69"></a><!-- doxytag: member="gridripper::multipole::sinTheta_partial_theta" ref="b8dc4d2e7949f3c68b35ca137ad69f69" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::sinTheta_partial_theta           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<img class="formulaInl" alt="$\sin(\vartheta)\partial_{\vartheta}$" src="form_61.png"> derivative on sphere for real scalar field. 
<p>
Based on the rule for <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a> basis. Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="aa406903fe05c91acc2e9893dc53ee54"></a><!-- doxytag: member="gridripper::multipole::SobolevConstantS2" ref="aa406903fe05c91acc2e9893dc53ee54" args="(const int m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::SobolevConstantS2           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The minimal Sobolev constant in the inequality over the sphere: <img class="formulaInl" alt="$\Vert\cdot\Vert_{C^{0}} \leq C \Vert\cdot\Vert_{H^{2}_{\mu}}$" src="form_50.png">. 
<p>
It is the sum <img class="formulaInl" alt="$\sqrt{\frac{1}{4\pi}\sum_{l=0}^{\infty} (2l+1)\frac{l(l+1)-1}{(l(l+1))^{\mu+1}-1}}$" src="form_51.png">. 
</div>
</div><p>
<a class="anchor" name="eed2535963dbe2006e701534b7624075"></a><!-- doxytag: member="gridripper::multipole::Sqr_partial_phi" ref="eed2535963dbe2006e701534b7624075" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::Sqr_partial_phi           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Second <img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for complex scalar field. 
<p>
Based on: <img class="formulaInl" alt="$\partial_{\varphi}\partial_{\varphi} Y_{l}^{m} = -m^{2} Y_{l}^{m}$" src="form_92.png">. 
</div>
</div><p>
<a class="anchor" name="f1a93dee2b7726ca194bd5cd914ee559"></a><!-- doxytag: member="gridripper::multipole::Sqr_partial_phi" ref="f1a93dee2b7726ca194bd5cd914ee559" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;<a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a>&gt; gridripper::multipole::Sqr_partial_phi           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Second <img class="formulaInl" alt="$\varphi$" src="form_9.png"> derivative on sphere for real scalar field. 
<p>
Based on: <img class="formulaInl" alt="$\partial_{\varphi}\partial_{\varphi} Yre_{l}^{m} = -m^{2} Yre_{l}^{m}$" src="form_60.png">. 
</div>
</div><p>
<a class="anchor" name="01543d028e956a562c9e5b26742f99fd"></a><!-- doxytag: member="gridripper::multipole::stepping" ref="01543d028e956a562c9e5b26742f99fd" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;, const int upOrDown)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarFieldMP&lt;GComplex_t&gt; gridripper::multipole::stepping           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>upOrDown</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stepping up and down operators. 
<p>
Based on: <img class="formulaInl" alt="$\mathrm{e}^{\mathrm{i}\varphi} (\partial_{\vartheta} + \cot(\vartheta)\mathrm{i}\partial_{\phi}) Y_{l}^{m} = \sqrt{l(l+1)-m(m+1)} Y_{l}^{m+1}$" src="form_84.png"> (stepping up, <img class="formulaInl" alt="$L_{+}$" src="form_85.png"> operator). <img class="formulaInl" alt="$\mathrm{e}^{-\mathrm{i}\varphi} (-\partial_{\vartheta} + \cot(\vartheta)\mathrm{i}\partial_{\phi}) Y_{l}^{m} = \sqrt{l(l+1)-m(m-1)} Y_{l}^{m-1}$" src="form_86.png"> (stepping down, <img class="formulaInl" alt="$L_{-}$" src="form_87.png"> operator).<p>
Numerically verified using a C++ code. 
</div>
</div><p>
<a class="anchor" name="4d102e73f6012014bfd53e709aff6255"></a><!-- doxytag: member="gridripper::multipole::tailErrorBoundS2" ref="4d102e73f6012014bfd53e709aff6255" args="(const ScalarFieldMP&lt; GComplex_t &gt; &amp;a, const int mup, const int mu, int *lmax, int *mmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::tailErrorBoundS2           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GComplex_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>mup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>mmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An upper bound for the tail sum in the <img class="formulaInl" alt="$H_{\mu}^{2}$" src="form_77.png"> norm, assuming that the field is in the space <img class="formulaInl" alt="$H_{\mu'}^{2}$" src="form_107.png">. 
<p>
In this case, its <a class="el" href="namespacegridripper_1_1multipole.html" title="Multipole expansion classes and methods.">multipole</a> coefficients may be bound by the sequence <img class="formulaInl" alt="$l \mapsto K \cdot \sqrt{\frac{l(l+1)-1}{(l(l+1))^{\mu'+1}-1}}\frac{1}{2l+1}$" src="form_108.png">. By adjusting <img class="formulaInl" alt="$K$" src="form_109.png"> to the stored coefficients, and by summing up the tail of this bound in the <img class="formulaInl" alt="$H_{\mu}^2$" src="form_54.png"> norm, one gets an upper estimate for the <img class="formulaInl" alt="$H_{\mu}^2$" src="form_54.png"> norm of the tail error. 
</div>
</div><p>
<a class="anchor" name="25d8ca9f24435bb928b62626e077b600"></a><!-- doxytag: member="gridripper::multipole::tailErrorBoundS2" ref="25d8ca9f24435bb928b62626e077b600" args="(const ScalarFieldMP&lt; GReal_t &gt; &amp;, const int mup, const int mu, int *lmax, int *mmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::tailErrorBoundS2           </td>
          <td>(</td>
          <td class="paramtype">const ScalarFieldMP&lt; GReal_t &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>mup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>mmax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An upper bound for the tail sum in <img class="formulaInl" alt="$H_{\mu}^{2}$" src="form_77.png"> norm, assuming that the field is in the space <img class="formulaInl" alt="$H_{\mu'}^2$" src="form_78.png">. 
<p>
Based on: same rule for complex. 
</div>
</div><p>
<a class="anchor" name="4efb9210174e454646c6ce517d769cae"></a><!-- doxytag: member="gridripper::multipole::YreYreYre_coupling" ref="4efb9210174e454646c6ce517d769cae" args="(const int l1, const int l2, const int l3, const int m1, const int m2, const int m3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::YreYreYre_coupling           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The same coupling for <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a> basis. 
<p>
They are real valued as <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a> -s are real valued. Zero if not: 1) <img class="formulaInl" alt="$l_1\geq 0$" src="form_18.png"> and <img class="formulaInl" alt="$l_2\geq 0$" src="form_19.png"> and <img class="formulaInl" alt="$l_3\geq 0$" src="form_20.png">, and 2) <img class="formulaInl" alt="$|m_1|\leq l_1$" src="form_21.png"> and <img class="formulaInl" alt="$|m2|\leq l_2$" src="form_28.png"> and <img class="formulaInl" alt="$|m_3|\leq l_3$" src="form_23.png">, and 3) <img class="formulaInl" alt="$|l_1-l_2|\leq l_3$" src="form_24.png"> and <img class="formulaInl" alt="$l_3\leq l_1+l_2$" src="form_25.png">, and 4) only zero or two of the <img class="formulaInl" alt="$\{m_1, m_2, m_3\}$" src="form_29.png"> are negative, and 5) <img class="formulaInl" alt="$(l_1+l_2+l_3)\%2=0$" src="form_27.png">. See <a class="el" href="Bases_8h-source.html">Bases.h</a> for definition of <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a> basis.<p>
Not tested numerically. Not used so far in multiplication operator.<p>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.5, 01/31/2007 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GridRipper 0.5 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andras Laszlo </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffa1b1c56cd150f3257677b858f7ac7f"></a><!-- doxytag: member="gridripper::multipole::YYreY_coupling" ref="ffa1b1c56cd150f3257677b858f7ac7f" args="(const int l1, const int l2, const int l3, const int m1, const int m2, const int m3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GComplex_t gridripper::multipole::YYreY_coupling           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar coupling for <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a> and <a class="el" href="classgridripper_1_1multipole_1_1Yre.html" title="Class for real spherical harmonic functions.">Yre</a> basis. 
<p>
They are not necessarily real valued. Zero if not: 1) <img class="formulaInl" alt="$l_1\geq 0$" src="form_18.png"> and <img class="formulaInl" alt="$l_2\geq 0$" src="form_19.png"> and <img class="formulaInl" alt="$l_3\geq 0$" src="form_20.png">, and 2) <img class="formulaInl" alt="$|m_1|\leq l_1$" src="form_21.png"> and <img class="formulaInl" alt="$|m_2|\leq l_2$" src="form_22.png"> and <img class="formulaInl" alt="$|m_3|\leq l_3$" src="form_23.png">, and 3) <img class="formulaInl" alt="$|l_1-l_2|\leq l_3$" src="form_24.png"> and <img class="formulaInl" alt="$l_3\leq l_1+l_2$" src="form_25.png">, and 4) <img class="formulaInl" alt="$m_1+m_2+m_3=0$" src="form_26.png"> or <img class="formulaInl" alt="$m_1-m_2+m_3=0$" src="form_30.png">, and 5) <img class="formulaInl" alt="$(l_1+l_2+l_3)\%2=0$" src="form_27.png">.<p>
Not tested numerically. Not used so far in multiplication operator.<p>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.5, 01/31/2007 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GridRipper 0.5 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andras Laszlo </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ad30d051132bf73154603e04085e96f"></a><!-- doxytag: member="gridripper::multipole::YYY_coupling" ref="9ad30d051132bf73154603e04085e96f" args="(const int l1, const int l2, const int l3, const int m1, const int m2, const int m3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegridripper.html#d0e021f7fcb8738cb2757cc49283917a">GReal_t</a> gridripper::multipole::YYY_coupling           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>l3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <img class="formulaInl" alt="$ \int_{0}^{\pi}\int_{0}^{2\pi} Y_{l_1}^{m_1}(\vartheta, \varphi) Y_{l_2}^{m_2}(\vartheta, \varphi) Y_{l_3}^{m_3}(\vartheta, \varphi) \;\sin(\vartheta)\mathrm{d}\vartheta\,\mathrm{d}\varphi $" src="form_17.png"> spherical harmonic function Gaunt coefficient calculator routine. 
<p>
Zero if not: 1) <img class="formulaInl" alt="$l_1\geq 0$" src="form_18.png"> and <img class="formulaInl" alt="$l_2\geq 0$" src="form_19.png"> and <img class="formulaInl" alt="$l_3\geq 0$" src="form_20.png">, and 2) <img class="formulaInl" alt="$|m_1|\leq l_1$" src="form_21.png"> and <img class="formulaInl" alt="$|m_2|\leq l_2$" src="form_22.png"> and <img class="formulaInl" alt="$|m_3|\leq l_3$" src="form_23.png">, and 3) <img class="formulaInl" alt="$|l_1-l_2|\leq l_3$" src="form_24.png"> and <img class="formulaInl" alt="$l_3\leq l_1+l_2$" src="form_25.png">, and 4) <img class="formulaInl" alt="$m_1+m_2+m_3=0$" src="form_26.png">, and 5) <img class="formulaInl" alt="$(l_1+l_2+l_3)\%2=0$" src="form_27.png">. Thus, by 4), they are real valued, which is not obvious otherwise. See <a class="el" href="Bases_8h-source.html">Bases.h</a> for definition of <a class="el" href="classgridripper_1_1multipole_1_1Y.html" title="Class for spherical harmonic functions.">Y</a> basis.<p>
Numerically verified using Maple.<p>
<dl class="version" compact><dt><b>Version:</b></dt><dd>0.5, 01/31/2007 </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GridRipper 0.5 </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andras Laszlo </dd></dl>

</div>
</div><p>
<a class="anchor" name="0261db9ddc27a4efc117b490be2df9a3"></a><!-- doxytag: member="gridripper::multipole::YYY_coupling_size" ref="0261db9ddc27a4efc117b490be2df9a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gridripper::multipole::YYY_coupling_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show table size currently used in YYY_coupling. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 17 18:46:57 2009 for GridRipper by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
